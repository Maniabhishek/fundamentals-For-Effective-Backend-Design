- Hashing is the process of converting data of any size (a word, a file, a password, etc.) into a fixed-size string of characters, usually a number or a combination of numbers/letters, using a hash function.

- Example
  - If we use a simple hash function like mod 10:
  - Input: 1234 → Hash: 4
  - Input: 5678 → Hash: 8
  - Input: 9876 → Hash: 6
No matter how big the input, the hash is always within a small, fixed range (here, 0–9).

- Key Properties of Hashing
  - Fixed size output → The hash is always of fixed length (e.g., 256 bits in SHA-256), no matter how large the input.
  - Deterministic → Same input will always produce the same hash.
  - Fast computation → Hashing should be quick.
  - Irreversible (one-way) → You can’t reconstruct the original input from the hash.
  - Collision resistant → Hard for two different inputs to have the same hash (though not impossible)
 
- Uses of Hashing
  - Data structures → Hash tables / hash maps (for fast lookups).
  - Security → Passwords stored as hashes, not plain text.
  - Data integrity → Hashes ensure a file hasn’t been tampered with (checksums).
  - Cryptography → Digital signatures, blockchain.

- Imagine a library with thousands of books. Instead of searching shelf by shelf, each book is assigned a unique code (hash) that directly tells you where it is. That’s why hash tables give you O(1) (constant time) lookup.

### How Hashing Helps in Password Storage
- You enter your password: mypassword123.
- The system runs it through a hash function (e.g., SHA-256).
- SHA-256("mypassword123") = ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
- This long fixed-length string (the hash) is stored in the database, not your actual password.
- Next login:
- You type mypassword123.
- System hashes it again with SHA-256.
- Compares with stored hash.
- If they match → ✅ password correct.
- Notice: The password itself never gets stored.

### What is SHA-256?
- SHA = Secure Hash Algorithm.
- 256 = length of the output (256 bits = 64 hex characters).
- Designed to be:
- Fast to compute.
- Irreversible (can’t get original input back).
- Collision resistant (hard for two different inputs to give same hash).
- It’s widely used in blockchain, digital signatures, and password hashing.


### Problem with Just SHA-256 for Passwords
- Attackers can still:
- Use rainbow tables (precomputed hash values for common passwords).
- Do brute force (hash millions of guesses per second).

### Solution → Salt + Hash
- Salt = A random string added to the password before hashing.
- Example
- password = "mypassword123"
- salt = "x8$k9!"
- SHA-256("mypassword123x8$k9!") = a totally new hash
- Even if two users pick the same password, their hashes will be different.
- Prevents rainbow table attacks.

### Even Better → Slow Hashing Functions
- Modern password storage doesn’t just use SHA-256. It uses algorithms designed to be computationally expensive, so brute force is much harder:
- bcrypt
- scrypt
- Argon2 (state-of-the-art)
- These are purposely slow and include built-in salting.
